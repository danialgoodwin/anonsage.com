<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#FF5722 name=theme-color> <meta content="Anonsage dev blog and cheat sheets" name=Description> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.1410966418.css rel=stylesheet><link href=client/client.1318f649.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Better programming language by Effective Java</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-12i6fi0><ul class=svelte-12i6fi0><li class=svelte-12i6fi0><a href=. class=svelte-12i6fi0>home</a></li> <li class=svelte-12i6fi0><a href=dev class=svelte-12i6fi0 rel=prefetch aria-current=page>dev</a></li> <li class=svelte-12i6fi0><a href=random class=svelte-12i6fi0 rel=prefetch>random</a></ul></nav> <main class=svelte-kr0vyj> <h1>Better programming language by Effective Java</h1> <small>2019-05-21</small> <div class=content><p>Programming language patterns and idioms come about because of limitations and weaknesses in the programming language.</p> <p>For example, the book 'Effective Java' by Joshua Bloch has 'Item 36. Consistently use the Override annotation'. I completely agree with this for Java. In fact, it should be an error without it. The Kotlin programming language requires their <code>override</code> keyword in cases of methods being overwritten. Thus, any 'Effective Kotlin' book would not have this Item 36.</p> <p>So, I got to thinking... what other Effective Java items could be made obsolete with a better programming language? (I just happen to use Kotlin as an example for most of these)</p> <h4 id=item-2-consider-a-builder-when-faced-with-many-constructor-parameters>Item 2: Consider a builder when faced with many constructor parameters</h4> <p>The reason the Builder pattern should be used in Java is because when we want to provide optional parameters, then the telescoping constructors become very verbose. And, the Builder pattern allows for a fluent API with an immutable class.</p> <p>In Kotlin, these reasons are overcome with the constructor using keywords that define each parameter as mutable (using <code>var</code>) or immutable (using <code>val</code>). The fluent API can be done with named parameters. And, optional parameters are done by providing a default value in the constructor.</p> <h4 id=item-3-enforce-the-singleton-pattern-with-a-private-constructor-or-an-enum-type>Item 3: Enforce the singleton pattern with a private constructor or an enum type</h4> <p>While Kotlin could use either of these ways for the singleton pattern, an alternative convenience keyword is <code>object</code>. This keyword replaces <code>class</code> and ensures the class is a singleton.</p> <h4 id=item-4-enforce-non-instantiability-with-a-private-constructor>Item 4: Enforce non-instantiability with a private constructor</h4> <p>A Java class without any instances is likely a utility class. The Kotlin way is to replace utility classes with extension functions, and no class needed.</p> <h4 id=item-6-eliminate-obsolete-object-references>Item 6: Eliminate obsolete object references</h4> <p>Here's a non-Kotlin example.</p> <p>In apps with a lifecycle (I'll be talking about Android specifically here), it is common to have listeners and services added in an onStart() method and removed in an onStop() method.</p> <p>Android's newest way to help prevent memory leaks and handle the explicit removal of object references is their <code>LiveData</code> class. Listeners/observers will be automatically removed as appropriate in the app lifecycle (in onStop()).</p> <h4 id=item-8-obey-the-general-contract-when-overriding-equals>Item 8: Obey the general contract when overriding equals</h4> <p>Or, for POJOs, use Kotlin's <code>data class</code> that will automatically create the correct equals(...) method.</p> <h4 id=item-9-always-override-hashcode-when-you-override-equals>Item 9: Always override hashCode when you override equals</h4> <p>Or, for POJOs, use Kotlin's <code>data class</code> that will automatically create the correct hashCode() method.</p> <h4 id=item-14-in-public-classes-use-accessor-methods-not-public-fields>Item 14: In public classes, use accessor methods, not public fields</h4> <p>I like how Ceylon and Kotlin handle fields, i.e. their ability to change how the getter and setter of the field works. So, accessor methods aren't needed as much for encapsulation because the fields also provide encapsulation.</p> <h4 id=item-18-prefer-interfaces-to-abstract-classes>Item 18: Prefer interfaces to abstract classes</h4> <p>In Java, what's the difference between interfaces and abstract classes? Both now provide optional/default methods. So, the only thing left is that abstract classes can have non-static fields and interfaces allow for multiple inheritance. But, using an abstract class doesn't prevent multiple inheritance of interfaces. So, the real difference is just the ability for non-static fields.</p> <p>I'm not sure why we need both abstract classes and interfaces. We could add the ability for interfaces (or something like it) to have non-static fields. Or, we could add the ability for multiple inheritance to classes (or something like it). We would not allow the edge case of the "diamond problem" from multiple inheritance; it would be a compile-time issue if the shared method (or field) wasn't overwritten.</p> <p>Or, maybe there is a good reason to have this distinction that I don't know about.</p> <hr> <p>And, now I'm out of time. It was fun to think about and there are plenty of other idioms and patterns that could be made obsolete with a better programming language. Question everything, and have a reason for each choice that is made.</p> <p>In whatever language you create, keep all of the reasons for each choice documented so that others can easily question each of those reasons and build off of that. :p</p> </div> <br><br><br> <a href=../dev/2019-05-17-initial-commit-with-orchid-and-netlify>&lt;Initial Commit with Orchid and Netlify</a> <div class=right><a href=../dev/2019-05-25-simple-sample-android-in-app-billing-v2-in-kotlin>Simple sample of Android in-app billing v2 in Kotlin></a></div></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cp\u003EProgramming language patterns and idioms come about because of limitations and weaknesses in the programming language.\u003C\u002Fp\u003E\n\u003Cp\u003EFor example, the book &#39;Effective Java&#39; by Joshua Bloch has &#39;Item 36. Consistently use the Override annotation&#39;. I completely agree with this for Java. In fact, it should be an error without it. The Kotlin programming language requires their \u003Ccode\u003Eoverride\u003C\u002Fcode\u003E keyword in cases of methods being overwritten. Thus, any &#39;Effective Kotlin&#39; book would not have this Item 36.\u003C\u002Fp\u003E\n\u003Cp\u003ESo, I got to thinking... what other Effective Java items could be made obsolete with a better programming language? (I just happen to use Kotlin as an example for most of these)\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-2-consider-a-builder-when-faced-with-many-constructor-parameters\"\u003EItem 2: Consider a builder when faced with many constructor parameters\u003C\u002Fh4\u003E\n\u003Cp\u003EThe reason the Builder pattern should be used in Java is because when we want to provide optional parameters, then the telescoping constructors become very verbose. And, the Builder pattern allows for a fluent API with an immutable class.\u003C\u002Fp\u003E\n\u003Cp\u003EIn Kotlin, these reasons are overcome with the constructor using keywords that define each parameter as mutable (using \u003Ccode\u003Evar\u003C\u002Fcode\u003E) or immutable (using \u003Ccode\u003Eval\u003C\u002Fcode\u003E). The fluent API can be done with named parameters. And, optional parameters are done by providing a default value in the constructor.\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-3-enforce-the-singleton-pattern-with-a-private-constructor-or-an-enum-type\"\u003EItem 3: Enforce the singleton pattern with a private constructor or an enum type\u003C\u002Fh4\u003E\n\u003Cp\u003EWhile Kotlin could use either of these ways for the singleton pattern, an alternative convenience keyword is \u003Ccode\u003Eobject\u003C\u002Fcode\u003E. This keyword replaces \u003Ccode\u003Eclass\u003C\u002Fcode\u003E and ensures the class is a singleton.\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-4-enforce-non-instantiability-with-a-private-constructor\"\u003EItem 4: Enforce non-instantiability with a private constructor\u003C\u002Fh4\u003E\n\u003Cp\u003EA Java class without any instances is likely a utility class. The Kotlin way is to replace utility classes with extension functions, and no class needed.\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-6-eliminate-obsolete-object-references\"\u003EItem 6: Eliminate obsolete object references\u003C\u002Fh4\u003E\n\u003Cp\u003EHere&#39;s a non-Kotlin example.\u003C\u002Fp\u003E\n\u003Cp\u003EIn apps with a lifecycle (I&#39;ll be talking about Android specifically here), it is common to have listeners and services added in an onStart() method and removed in an onStop() method.\u003C\u002Fp\u003E\n\u003Cp\u003EAndroid&#39;s newest way to help prevent memory leaks and handle the explicit removal of object references is their \u003Ccode\u003ELiveData\u003C\u002Fcode\u003E class. Listeners\u002Fobservers will be automatically removed as appropriate in the app lifecycle (in onStop()).\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-8-obey-the-general-contract-when-overriding-equals\"\u003EItem 8: Obey the general contract when overriding equals\u003C\u002Fh4\u003E\n\u003Cp\u003EOr, for POJOs, use Kotlin&#39;s \u003Ccode\u003Edata class\u003C\u002Fcode\u003E that will automatically create the correct equals(...) method.\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-9-always-override-hashcode-when-you-override-equals\"\u003EItem 9: Always override hashCode when you override equals\u003C\u002Fh4\u003E\n\u003Cp\u003EOr, for POJOs, use Kotlin&#39;s \u003Ccode\u003Edata class\u003C\u002Fcode\u003E that will automatically create the correct hashCode() method.\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-14-in-public-classes-use-accessor-methods-not-public-fields\"\u003EItem 14: In public classes, use accessor methods, not public fields\u003C\u002Fh4\u003E\n\u003Cp\u003EI like how Ceylon and Kotlin handle fields, i.e. their ability to change how the getter and setter of the field works. So, accessor methods aren&#39;t needed as much for encapsulation because the fields also provide encapsulation.\u003C\u002Fp\u003E\n\u003Ch4 id=\"item-18-prefer-interfaces-to-abstract-classes\"\u003EItem 18: Prefer interfaces to abstract classes\u003C\u002Fh4\u003E\n\u003Cp\u003EIn Java, what&#39;s the difference between interfaces and abstract classes? Both now provide optional\u002Fdefault methods. So, the only thing left is that abstract classes can have non-static fields and interfaces allow for multiple inheritance. But, using an abstract class doesn&#39;t prevent multiple inheritance of interfaces. So, the real difference is just the ability for non-static fields.\u003C\u002Fp\u003E\n\u003Cp\u003EI&#39;m not sure why we need both abstract classes and interfaces. We could add the ability for interfaces (or something like it) to have non-static fields. Or, we could add the ability for multiple inheritance to classes (or something like it). We would not allow the edge case of the &quot;diamond problem&quot; from multiple inheritance; it would be a compile-time issue if the shared method (or field) wasn&#39;t overwritten.\u003C\u002Fp\u003E\n\u003Cp\u003EOr, maybe there is a good reason to have this distinction that I don&#39;t know about.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003EAnd, now I&#39;m out of time. It was fun to think about and there are plenty of other idioms and patterns that could be made obsolete with a better programming language. Question everything, and have a reason for each choice that is made.\u003C\u002Fp\u003E\n\u003Cp\u003EIn whatever language you create, keep all of the reasons for each choice documented so that others can easily question each of those reasons and build off of that. :p\u003C\u002Fp\u003E\n",title:"Better programming language by Effective Java",tags:["Java","Kotlin","Language Design"],file:"2019-05-21-better-programming-language-by-effective-java.md",date:"2019-05-21",slug:"2019-05-21-better-programming-language-by-effective-java",next:{slug:"2019-05-25-simple-sample-android-in-app-billing-v2-in-kotlin",name:"Simple sample of Android in-app billing v2 in Kotlin"},previous:{slug:"2019-05-17-initial-commit-with-orchid-and-netlify",name:"Initial Commit with Orchid and Netlify"}}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.1318f649.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.1318f649.js")}document.head.appendChild(s)</script> 