<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#FF5722 name=theme-color> <meta content="Anonsage dev blog and cheat sheets" name=Description> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.1410966418.css rel=stylesheet><link href=client/client.e984a261.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Implementation</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-12i6fi0><ul class=svelte-12i6fi0><li class=svelte-12i6fi0><a href=. class=svelte-12i6fi0>home</a></li> <li class=svelte-12i6fi0><a href=dev class=svelte-12i6fi0 rel=prefetch>dev</a></li> <li class=svelte-12i6fi0><a href=random class=svelte-12i6fi0 rel=prefetch>random</a></li> <li class=svelte-12i6fi0><a href=anonlang class=svelte-12i6fi0 rel=prefetch aria-current=page>anonlang</a></li> <li class=svelte-12i6fi0><a href=products class=svelte-12i6fi0 rel=prefetch>products</a></ul></nav> <main class=svelte-kr0vyj> <h1>Implementation</h1> <small>2015-08-18</small> <div class=content><p>Originally, I was thinking about making an adapter to convert between Anonlang to something like Java'a <code>LinkedHashMap</code>, which does seem to fix the scope of features that I'm looking for in an easy manner.</p> <p>Another idea is to forgo the traditional data structure idea. I'm sure this has been subconscious in my mind for awhile. And, more of it still is. The basic idea is that the format as written would be the data structure and wouldn't need to be converted into anything else to be used directly. Though, since large paradigms are hard to break habit/thought, the old paradigm metaphor could be very roughly similar to that of a <code>String</code> (program as typed by dev) and it would be containing self-pointers/references to the other "String" parts it holds.</p> <p>In this case, if Anonlang were considered more as a "markup" language, then it'd be more possible to avoid the initial pass-through and parsing of converting to the (possible) large LinkedHashMap (or similar). Things at first my be all lazy-loaded. If also doing lazy-(functional)-work, then possibly more cycles could be saved.</p> <p>Sidenote: Every now and then, I may mention something that may seem to allude to "performance", but this isn't particularly the main concern for now. It might just be talked about at very high level, just noting that it wouldn't be performant (mainly when compared to a traditional language). There are many parts of this language that are ahead of its time. And, exact implementation details can be figured out latter and changed if necessary. At this time more focus is going into the overall architecture and larger goal-views.</p> <p>Update: When re-visiting Google's cross-platform '<a href=https://github.com/google/flatbuffers>FlatBuffers</a>', it seems that would be the similar style for 'parsing' this language also. It is some great and clever work.</p> </div> <br><br><br> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cp\u003EOriginally, I was thinking about making an adapter to convert between Anonlang to something like Java&#39;a \u003Ccode\u003ELinkedHashMap\u003C\u002Fcode\u003E, which does seem to fix the scope of features that I&#39;m looking for in an easy manner.\u003C\u002Fp\u003E\n\u003Cp\u003EAnother idea is to forgo the traditional data structure idea. I&#39;m sure this has been subconscious in my mind for awhile. And, more of it still is. The basic idea is that the format as written would be the data structure and wouldn&#39;t need to be converted into anything else to be used directly. Though, since large paradigms are hard to break habit\u002Fthought, the old paradigm metaphor could be very roughly similar to that of a \u003Ccode\u003EString\u003C\u002Fcode\u003E (program as typed by dev) and it would be containing self-pointers\u002Freferences to the other &quot;String&quot; parts it holds.\u003C\u002Fp\u003E\n\u003Cp\u003EIn this case, if Anonlang were considered more as a &quot;markup&quot; language, then it&#39;d be more possible to avoid the initial pass-through and parsing of converting to the (possible) large LinkedHashMap (or similar). Things at first my be all lazy-loaded. If also doing lazy-(functional)-work, then possibly more cycles could be saved.\u003C\u002Fp\u003E\n\u003Cp\u003ESidenote: Every now and then, I may mention something that may seem to allude to &quot;performance&quot;, but this isn&#39;t particularly the main concern for now. It might just be talked about at very high level, just noting that it wouldn&#39;t be performant (mainly when compared to a traditional language). There are many parts of this language that are ahead of its time. And, exact implementation details can be figured out latter and changed if necessary. At this time more focus is going into the overall architecture and larger goal-views.\u003C\u002Fp\u003E\n\u003Cp\u003EUpdate: When re-visiting Google&#39;s cross-platform &#39;\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgoogle\u002Fflatbuffers\"\u003EFlatBuffers\u003C\u002Fa\u003E&#39;, it seems that would be the similar style for &#39;parsing&#39; this language also. It is some great and clever work.\u003C\u002Fp\u003E\n",title:"Implementation",file:"2015-08-18-implementation.md",date:"2015-08-18",slug:"2015-08-18-implementation"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.e984a261.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.e984a261.js")}document.head.appendChild(s)</script> <script async data-goatcounter=https://anonsage.goatcounter.com/count src=//gc.zgo.at/count.js></script> 