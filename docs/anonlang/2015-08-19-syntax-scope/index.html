<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#FF5722 name=theme-color> <meta content="Anonsage dev blog and cheat sheets" name=Description> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.1410966418.css rel=stylesheet><link href=client/client.9074a2b4.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Syntax: Scope</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-12i6fi0><ul class=svelte-12i6fi0><li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=.>home</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=dev rel=prefetch>dev</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=random rel=prefetch>random</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=anonlang rel=prefetch aria-current=page>anonlang</a></ul></nav> <main class=svelte-kr0vyj> <h1>Syntax: Scope</h1> <small>2015-08-19</small> <div class=content><p>Challenge: Make simpler scoping rules that are still both human and computer parse-able.</p> <p>I'm not saying that the current 'traditional' style is bad or hard. I'm quite used to it. But, we can at least try to think of possible alternatives.</p> <p>Though experiment: Is it possible to only use square brackets in a language and not have to use either the curly brace or parenthesis?</p> <p>Here's just a few possible ideas for the above thought experiment:</p> <p>'traditional':</p> <pre class=language-javascriptreact><code><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>myFunctionName</span> (<span class=hljs-params>int aInt, String aString</span>) </span>{ <span class=hljs-comment>/* Do something in scope with arguments */</span> }

<span class=hljs-keyword>while</span> (i &lt; length) { <span class=hljs-comment>/* Do something */</span> }</code></pre><p>Semantically same (for theoretical language):</p> <pre class=language-javascriptreact><code>[<span class=hljs-string>`int aInt, String aString`</span> [; Do something <span class=hljs-keyword>in</span> scope <span class=hljs-keyword>with</span> argument;] ]

[<span class=hljs-string>`i &lt; length`</span> [; Do something ;] :]</code></pre><p>Hmm, this challenge may have been too easy. We may just have to look at Lisp to see everything being done with parenthesis. It seems that I may have stumbled upon some same ideas that original Lisp creators had. On that note, same with functional elements, like in Haskell. And, this is all still being attempted to have ideas from scratch with reasons for each step of the way other than 'other languages do it, so I should too'.</p> <p>One difference with Lisp for this theoretical language is that Lisp has the function name inside the 'scope'. For Anonlang, items declared within scopes would only be available within that scope, so the function name would have to be on the outside. Also, 'function name' would just be an 'alias' for the 'named' scope.. to use terms that might be more 'technical' in the language.</p> <p>Random thought now: Every scope is a for-loop in disguise? Ex: [<code>int i = 0; i &lt; length; i++</code> [; Do something ;] ]</p> <p>Then, parts of the 'for-loop' could just be left out when wanting to do other things. Leaving out last two 'for-loop-argument` seems like it could create the function being called one with an (optional) parameter. It seems that there are no differences between a regular no-arg function and for-loop that is only ran through once... This could quite possibly simplify Anonlang code...</p> </div> <br><br><br> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cp\u003EChallenge: Make simpler scoping rules that are still both human and computer parse-able.\u003C\u002Fp\u003E\n\u003Cp\u003EI&#39;m not saying that the current &#39;traditional&#39; style is bad or hard. I&#39;m quite used to it. But, we can at least try to think of possible alternatives.\u003C\u002Fp\u003E\n\u003Cp\u003EThough experiment: Is it possible to only use square brackets in a language and not have to use either the curly brace or parenthesis?\u003C\u002Fp\u003E\n\u003Cp\u003EHere&#39;s just a few possible ideas for the above thought experiment:\u003C\u002Fp\u003E\n\u003Cp\u003E&#39;traditional&#39;:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EmyFunctionName\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Eint aInt, String aString\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{ \u003Cspan class=\"hljs-comment\"\u003E\u002F* Do something in scope with arguments *\u002F\u003C\u002Fspan\u003E }\n\n\u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E (i &lt; length) { \u003Cspan class=\"hljs-comment\"\u003E\u002F* Do something *\u002F\u003C\u002Fspan\u003E }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ESemantically same (for theoretical language):\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E[\u003Cspan class=\"hljs-string\"\u003E`int aInt, String aString`\u003C\u002Fspan\u003E [; Do something \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E scope \u003Cspan class=\"hljs-keyword\"\u003Ewith\u003C\u002Fspan\u003E argument;] ]\n\n[\u003Cspan class=\"hljs-string\"\u003E`i &lt; length`\u003C\u002Fspan\u003E [; Do something ;] :]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EHmm, this challenge may have been too easy. We may just have to look at Lisp to see everything being done with parenthesis. It seems that I may have stumbled upon some same ideas that original Lisp creators had. On that note, same with functional elements, like in Haskell. And, this is all still being attempted to have ideas from scratch with reasons for each step of the way other than &#39;other languages do it, so I should too&#39;.\u003C\u002Fp\u003E\n\u003Cp\u003EOne difference with Lisp for this theoretical language is that Lisp has the function name inside the &#39;scope&#39;. For Anonlang, items declared within scopes would only be available within that scope, so the function name would have to be on the outside. Also, &#39;function name&#39; would just be an &#39;alias&#39; for the &#39;named&#39; scope.. to use terms that might be more &#39;technical&#39; in the language.\u003C\u002Fp\u003E\n\u003Cp\u003ERandom thought now: Every scope is a for-loop in disguise? Ex: [\u003Ccode\u003Eint i = 0; i &lt; length; i++\u003C\u002Fcode\u003E [; Do something ;] ]\u003C\u002Fp\u003E\n\u003Cp\u003EThen, parts of the &#39;for-loop&#39; could just be left out when wanting to do other things. Leaving out last two &#39;for-loop-argument` seems like it could create the function being called one with an (optional) parameter. It seems that there are no differences between a regular no-arg function and for-loop that is only ran through once... This could quite possibly simplify Anonlang code...\u003C\u002Fp\u003E\n",title:"Syntax: Scope",file:"2015-08-19-syntax-scope.md",date:"2015-08-19",slug:"2015-08-19-syntax-scope"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.9074a2b4.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.9074a2b4.js")}document.head.appendChild(s)</script> <script async data-goatcounter=https://anonsage.goatcounter.com/count src=//gc.zgo.at/count.js></script> 