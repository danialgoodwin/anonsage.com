<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#FF5722 name=theme-color> <meta content="Anonsage dev blog and cheat sheets" name=Description> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.1410966418.css rel=stylesheet><link href=client/client.779d72bd.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Better Functions, Methods, and Fields</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-12i6fi0><ul class=svelte-12i6fi0><li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=.>home</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=dev rel=prefetch>dev</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=random rel=prefetch>random</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=anonlang rel=prefetch aria-current=page>anonlang</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=products rel=prefetch>products</a></ul></nav> <main class=svelte-kr0vyj> <h1>Better Functions, Methods, and Fields</h1> <small>2015-03-21</small> <div class=content><p>(For easier writing of this section, I will use refer to functions and methods as to just functions. (Abstraction for the win!))</p> <p>Here's a thought: let's not have to write the boilerplate for every function (and method) and field that we want to create.</p> <p>Here's a crazier thought: when writing code, let's not have to differentiate between whether we are writing a function or field.</p> <p>We don't need to define whether something is a function or field. They both (optionally) return a value and have zero or more arguments (traditional fields are always zero arguments).</p> <p>As an example, I will write the same (trivial) code in Java and "Anonlang" where the only difference is the one idea talked about in this section, meaning not the final ideal Anonlang. (And, I just threw in a "readable" modifier just so that we can experiment with that idea. Perhaps something more granular like unix file security model would be better? But, that's for a different section)</p> <pre class=language-javascriptreact><code><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>MyJavaClass</span> </span>{
    private int key;
    private <span class=hljs-built_in>String</span> value;
    public boolean isSet;
    public MyJavaClass(int key, <span class=hljs-built_in>String</span> value) { <span class=hljs-keyword>this</span>.key = key; <span class=hljs-keyword>this</span>.value = value; }
    public int getKey() { <span class=hljs-keyword>return</span> key; }
    public <span class=hljs-built_in>String</span> getValue() { <span class=hljs-keyword>return</span> value; }
}

MyAnonlangClass(int key, <span class=hljs-built_in>String</span> value) {
<span class=hljs-comment>//MyAnonlangClass(readables) { // Random idea for no duplication.</span>
    readable int key;
    readable <span class=hljs-built_in>String</span> value;
    shared boolean isSet;
}</code></pre><p>For this contrived example, to refactor Java to make <code>isSet</code> private, you must create a new method and change how all other objects interact with the class. The ideal refactoring would involve just changing the <code>shared boolean isSet</code> line to something like:</p> <pre class=language-javascriptreact><code>shared boolean isSet {
    <span class=hljs-keyword>return</span> key != <span class=hljs-number>0</span> && value.isNotEmpty;
    <span class=hljs-comment>//return key && value; // Random experimental idea because all objects have a natural "false" state that could be exploited.</span>
}</code></pre><p>Thus, not having to refactor anywhere else that was already pointing to the <code>isSet</code> field-now-method.</p> <p>Pros:</p> <ul> <li>Changing implementation details without changing the public API (and without the boilerplate)</li> <li>Provide a way to encourage more lazy loading</li> <li>Write less code and more readable</li> </ul> <p>Cons:</p> <ul> <li>At a quick glance in a regular text editor, you may not know if the attribute (aka function/field) should be read from or written to. Workaround: Basic tooling can prevent you from doing the wrong thing at edit-time.</li> <li>The program wouldn't know when something had to be just calculated once or every time. Fix: There could likely be a property attribute for that. Perhaps, even allow dynamic programming by default or calculating once per specified time-length. Or, maybe, even the compiler and/or runtime environment would be able to figure that out automatically and apply the proper operation (if not explicitly set by dev).</li> </ul> <p>Designing the ideal language takes time and different perspectives. Feel free to input more ideas related to combining the functions and fields. What other pros and cons are there?</p> <p><small>ps - The "Anonlang" syntax shown is not the final one. For purposes of this section, it was just kept similar to the compared language so that more people would quickly understand it. These other syntax changes will be discussed in other sections.</small></p> </div> <br><br><br> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cp\u003E(For easier writing of this section, I will use refer to functions and methods as to just functions. (Abstraction for the win!))\u003C\u002Fp\u003E\n\u003Cp\u003EHere&#39;s a thought: let&#39;s not have to write the boilerplate for every function (and method) and field that we want to create.\u003C\u002Fp\u003E\n\u003Cp\u003EHere&#39;s a crazier thought: when writing code, let&#39;s not have to differentiate between whether we are writing a function or field.\u003C\u002Fp\u003E\n\u003Cp\u003EWe don&#39;t need to define whether something is a function or field. They both (optionally) return a value and have zero or more arguments (traditional fields are always zero arguments).\u003C\u002Fp\u003E\n\u003Cp\u003EAs an example, I will write the same (trivial) code in Java and &quot;Anonlang&quot; where the only difference is the one idea talked about in this section, meaning not the final ideal Anonlang. (And, I just threw in a &quot;readable&quot; modifier just so that we can experiment with that idea. Perhaps something more granular like unix file security model would be better? But, that&#39;s for a different section)\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EMyJavaClass\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n    private int key;\n    private \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E value;\n    public boolean isSet;\n    public MyJavaClass(int key, \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E value) { \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.key = key; \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.value = value; }\n    public int getKey() { \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E key; }\n    public \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E getValue() { \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E value; }\n}\n\nMyAnonlangClass(int key, \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E value) {\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002FMyAnonlangClass(readables) { \u002F\u002F Random idea for no duplication.\u003C\u002Fspan\u003E\n    readable int key;\n    readable \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E value;\n    shared boolean isSet;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EFor this contrived example, to refactor Java to make \u003Ccode\u003EisSet\u003C\u002Fcode\u003E private, you must create a new method and change how all other objects interact with the class. The ideal refactoring would involve just changing the \u003Ccode\u003Eshared boolean isSet\u003C\u002Fcode\u003E line to something like:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003Eshared boolean isSet {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E key != \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &amp;&amp; value.isNotEmpty;\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Freturn key &amp;&amp; value; \u002F\u002F Random experimental idea because all objects have a natural \"false\" state that could be exploited.\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThus, not having to refactor anywhere else that was already pointing to the \u003Ccode\u003EisSet\u003C\u002Fcode\u003E field-now-method.\u003C\u002Fp\u003E\n\u003Cp\u003EPros:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EChanging implementation details without changing the public API (and without the boilerplate)\u003C\u002Fli\u003E\n\u003Cli\u003EProvide a way to encourage more lazy loading\u003C\u002Fli\u003E\n\u003Cli\u003EWrite less code and more readable\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ECons:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAt a quick glance in a regular text editor, you may not know if the attribute (aka function\u002Ffield) should be read from or written to. Workaround: Basic tooling can prevent you from doing the wrong thing at edit-time.\u003C\u002Fli\u003E\n\u003Cli\u003EThe program wouldn&#39;t know when something had to be just calculated once or every time. Fix: There could likely be a property attribute for that. Perhaps, even allow dynamic programming by default or calculating once per specified time-length. Or, maybe, even the compiler and\u002For runtime environment would be able to figure that out automatically and apply the proper operation (if not explicitly set by dev).\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EDesigning the ideal language takes time and different perspectives. Feel free to input more ideas related to combining the functions and fields. What other pros and cons are there?\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Csmall\u003Eps - The &quot;Anonlang&quot; syntax shown is not the final one. For purposes of this section, it was just kept similar to the compared language so that more people would quickly understand it. These other syntax changes will be discussed in other sections.\u003C\u002Fsmall\u003E\u003C\u002Fp\u003E\n",title:"Better Functions, Methods, and Fields",file:"2015-03-21-better-functions-methods-fields.md",date:"2015-03-21",slug:"2015-03-21-better-functions-methods-fields"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.779d72bd.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.779d72bd.js")}document.head.appendChild(s)</script> <script async data-goatcounter=https://anonsage.goatcounter.com/count src=//gc.zgo.at/count.js></script> 