{"html":"<p>Instead of considering any limitations that current languages, parsers, and computers have, let&#39;s start from the front-end of the new language... How should it be written and read.</p>\n<p>Higher abstractions tend to be good, and provide useful productivity boosts. So, let&#39;s start with an extreme.. what&#39;s the minimal working code we can write for any given program or algorithm? We will start by removing absolutely all boilerplate.</p>\n<p>Once, this extreme is designed and gone through the rabbit hole, then we might consider allowing more (possibly optional) verbosity to make reading and maintaining the code easier.</p>\n<p>No boilerplate.</p>\n<p>Imagine how you would feel writing that, and how productive you would be.</p>\n<p>We&#39;ll talk more specifics later. For now, question everything that your language does. Imagine for a moment that you didn&#39;t have to worry about the underlying performance of the system and what the compiler does, because in the ideal language, you wouldn&#39;t have to.</p>\n","title":"Language Design for Developers First","file":"2015-03-14-language-design-for-developers-first.md","date":"2015-03-14","slug":"2015-03-14-language-design-for-developers-first"}