<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#FF5722 name=theme-color> <meta content="Anonsage dev blog and cheat sheets" name=Description> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.1410966418.css rel=stylesheet><link href=client/client.510a3652.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Pattern: MVC</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-12i6fi0><ul class=svelte-12i6fi0><li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=.>home</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=dev rel=prefetch>dev</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=random rel=prefetch>random</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=anonlang rel=prefetch aria-current=page>anonlang</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=products rel=prefetch>products</a></ul></nav> <main class=svelte-kr0vyj> <h1>Pattern: MVC</h1> <small>2015-08-18</small> <div class=content><p>One possibly important aspect will be to easily support the MVC (Model-View-Controller). In this post, I don't need to talk about MVP and MVVM because they are similar enough to be supported the same way.</p> <p>The question I have is.. is it possible to set up everything so that the final binding of code could look like the following?</p> <pre class=language-javascriptreact><code>[controller] * [view] * [model]</code></pre><p>For some trivial examples with simple data and labels, something very similar to this is already being worked on. It definitely brings a way to have source-data brought to function, in the manner of <code>[function] * [data]</code>. Hmm, that does seem oddly familiar to a "traditional" function call like <code>function (data) {}</code>, where the data being passed in is abstracted from the function.</p> <p>So, separation of concerns between model and data seems easy enough. First define a model, <code>[car]</code>, then create some data, <code>[car-data]</code>. Then, to "add"/"load" the data into the model, it could be like <code>[car] * [car-data]</code>, just kinda like linear algebra. Another, possibly easier, way to think about this as the [car] model to be just attribute name (maybe even column names for a table), and each [car-data] data to be assigning a value for each of the attributes (like adding a row of data to a column).</p> <p>Then, similarly might be done with binding a model to a view.. perhaps (the syntax made up on-the-stop), <code>[view] &lt;=> [model]</code>. Would that be smart enough to have binding both ways without circular dependency? Certainly, naive code could create circular dependencies. Though, we would want to minimize the accidental chance of that happening.</p> <p>Hmm, a thought.. a "controller" really is just an "adapter".. It allows "models" to be "coerced" into "views"...</p> <p>Is it just so that the model and view don't have a dependency on each other?</p> <p>Yes. The MVC pattern isn't just three files that talk directly to each other. Proper abstraction/encapsulation between different codes requires interfaces/adapters so that implementation details can be changed without affecting the API (internal or external), thus simplifying refactorings.</p> <p>(Sidenote: That's only because it's more work to edit same/similar in multiple files. To fight that issue directly, would it be possible to have all the code in the same place instead, thus eliminating the need for extra layers of abstraction? The 'view' can be the 'model'?)</p> <p>So, back on track, for a solid MVC pattern, the Controller is like the abstraction layer between Model and View for simple projects. As a project grows and needs different views for the same models, an abstraction layer would be added between C and V. Then, as more Models are needed, an abstraction layer would be added between M and C. This is all in an effort to have more (and easier) code reuse. As each part of a M or V get more complicated, more (smaller scope) abstractions are added within the M or V or C. Turtles all the way down.</p> <p>So, again, a really important point to consider and think through more is... how can we simplify code architecture to not need the many layers of abstraction. I believe it is possible, and it will require a paradigm shift in the way or our thinking.</p> <p>More later.</p> </div> <br><br><br> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cp\u003EOne possibly important aspect will be to easily support the MVC (Model-View-Controller). In this post, I don&#39;t need to talk about MVP and MVVM because they are similar enough to be supported the same way.\u003C\u002Fp\u003E\n\u003Cp\u003EThe question I have is.. is it possible to set up everything so that the final binding of code could look like the following?\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E[controller] * [view] * [model]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EFor some trivial examples with simple data and labels, something very similar to this is already being worked on. It definitely brings a way to have source-data brought to function, in the manner of \u003Ccode\u003E[function] * [data]\u003C\u002Fcode\u003E. Hmm, that does seem oddly familiar to a &quot;traditional&quot; function call like \u003Ccode\u003Efunction (data) {}\u003C\u002Fcode\u003E, where the data being passed in is abstracted from the function.\u003C\u002Fp\u003E\n\u003Cp\u003ESo, separation of concerns between model and data seems easy enough. First define a model, \u003Ccode\u003E[car]\u003C\u002Fcode\u003E, then create some data, \u003Ccode\u003E[car-data]\u003C\u002Fcode\u003E. Then, to &quot;add&quot;\u002F&quot;load&quot; the data into the model, it could be like \u003Ccode\u003E[car] * [car-data]\u003C\u002Fcode\u003E, just kinda like linear algebra. Another, possibly easier, way to think about this as the [car] model to be just attribute name (maybe even column names for a table), and each [car-data] data to be assigning a value for each of the attributes (like adding a row of data to a column).\u003C\u002Fp\u003E\n\u003Cp\u003EThen, similarly might be done with binding a model to a view.. perhaps (the syntax made up on-the-stop), \u003Ccode\u003E[view] &lt;=&gt; [model]\u003C\u002Fcode\u003E. Would that be smart enough to have binding both ways without circular dependency? Certainly, naive code could create circular dependencies. Though, we would want to minimize the accidental chance of that happening.\u003C\u002Fp\u003E\n\u003Cp\u003EHmm, a thought.. a &quot;controller&quot; really is just an &quot;adapter&quot;.. It allows &quot;models&quot; to be &quot;coerced&quot; into &quot;views&quot;...\u003C\u002Fp\u003E\n\u003Cp\u003EIs it just so that the model and view don&#39;t have a dependency on each other?\u003C\u002Fp\u003E\n\u003Cp\u003EYes. The MVC pattern isn&#39;t just three files that talk directly to each other. Proper abstraction\u002Fencapsulation between different codes requires interfaces\u002Fadapters so that implementation details can be changed without affecting the API (internal or external), thus simplifying refactorings.\u003C\u002Fp\u003E\n\u003Cp\u003E(Sidenote: That&#39;s only because it&#39;s more work to edit same\u002Fsimilar in multiple files. To fight that issue directly, would it be possible to have all the code in the same place instead, thus eliminating the need for extra layers of abstraction? The &#39;view&#39; can be the &#39;model&#39;?)\u003C\u002Fp\u003E\n\u003Cp\u003ESo, back on track, for a solid MVC pattern, the Controller is like the abstraction layer between Model and View for simple projects. As a project grows and needs different views for the same models, an abstraction layer would be added between C and V. Then, as more Models are needed, an abstraction layer would be added between M and C. This is all in an effort to have more (and easier) code reuse. As each part of a M or V get more complicated, more (smaller scope) abstractions are added within the M or V or C. Turtles all the way down.\u003C\u002Fp\u003E\n\u003Cp\u003ESo, again, a really important point to consider and think through more is... how can we simplify code architecture to not need the many layers of abstraction. I believe it is possible, and it will require a paradigm shift in the way or our thinking.\u003C\u002Fp\u003E\n\u003Cp\u003EMore later.\u003C\u002Fp\u003E\n",title:"Pattern: MVC",file:"2015-08-18-pattern-mvc.md",date:"2015-08-18",slug:"2015-08-18-pattern-mvc"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.510a3652.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.510a3652.js")}document.head.appendChild(s)</script> <script async data-goatcounter=https://anonsage.goatcounter.com/count src=//gc.zgo.at/count.js></script> 