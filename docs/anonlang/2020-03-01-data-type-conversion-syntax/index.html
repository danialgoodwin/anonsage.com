<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#FF5722 name=theme-color> <meta content="Anonsage dev blog and cheat sheets" name=Description> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.1410966418.css rel=stylesheet><link href=client/client.4edb8f75.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Data Type Conversion Syntax</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-12i6fi0><ul class=svelte-12i6fi0><li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=.>home</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=dev rel=prefetch>dev</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=random rel=prefetch>random</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=anonlang rel=prefetch aria-current=page>anonlang</a></li> <li class=svelte-12i6fi0><a class=svelte-12i6fi0 href=products rel=prefetch>products</a></ul></nav> <main class=svelte-kr0vyj> <h1>Data Type Conversion Syntax</h1> <small>2020-03-01</small> <div class=content><p>This should be a really short post. There's not many possible ways of casting data types, right? So, in no particular order:</p> <ul> <li><code>str(42)</code></li> <li><code>42.toString()</code></li> <li><code>(String) 42</code></li> <li><code>42 as string</code></li> <li>(implicit) <code>42</code></li> </ul> <p>We probably can't do much better than these ideas above. But, we <em>can</em> think about which option is the most intuitive for new programmers, and which syntax would fit well with the rest of the language, and which syntax is open enough for many other conversion types (including custom classes)</p> <h3 id=re-str42>Re: <code>str(42)</code></h3> <p>The String type is the most commonly used data type, so it would make sense to simplify its usage. The 3-letter lower-case abbreviation is memorable enough after a few uses. Even though Python has <code>str()</code> as a built-in standard method, programmers can have the same syntax with overloaded constructors in their custom classes, i.e., <code>MyClass(...)</code>. Unfortunately, one way that the built-in syntax is different than the custom syntax is that the built-in syntaxes are all lower-case and the classes are all starting with upper-case. Also, is the 'str' abbreviation better than just having a 'text' data type instead of 'string' data type?</p> <h3 id=re-42tostring>Re: <code>42.toString()</code></h3> <p>Languages using this syntax either can't use the same syntax to convert from built-in data types to custom data types (classes), OR they have the concept of extension methods, which I really like having. With this syntax, IDEs could easily have auto-complete and suggestion for all possible conversions by doing <code>.to&lt;ctrl+space></code>.</p> <h4 id=re-42str>Re: <code>42.str</code></h4> <p>This is a degenerative form of <code>42.toString()</code>.</p> <p>I did consider a version of this syntax for a little bit, but when working on a few more examples later in this post, I figured this syntax wouldn't be as intuitive or obvious in some cases, for example: <code>day.seconds</code> would be ambiguous. It could mean getting the seconds out of the day rather than converting the full day to seconds. We would want to reserve this syntax for easily getting properties of an object rather than converting.</p> <h3 id=re-string-42>Re: <code>(String) 42</code></h3> <p>This option creates a brand new syntax just for casting. Instead of choosing this less intuitive route, let's see if we can re-use existing syntax to handle this data type conversion requirement. (Answer: Yes, we can)</p> <h3 id=re-42-as-string>Re: <code>42 as string</code></h3> <p>I kind of liked how this syntax read, including <code>42 to String</code>. But, since I just complained about creating a new syntax for casting in the previous section. I'll hold off on this one for now. </p> <h3 id=re-implicit-42>Re: (implicit) <code>42</code></h3> <p>Personally, I prefer explicit syntax in order to avoid simple mistakes.</p> <h2 id=summary>Summary</h2> <p>Currently, my top two choices for data type casting is <code>.toString()</code> and the more 'English' version of that <code>to String</code>.</p> <p>Now, let's just list a few more examples to see these two syntax in action:</p> <pre class=language-javascriptreact><code>days <span class=hljs-keyword>as</span> seconds
days to seconds
days.toSeconds()

hours <span class=hljs-keyword>as</span> days
hours to days
hours.toDays()

km <span class=hljs-keyword>as</span> m
km to m
km.toM()

number <span class=hljs-keyword>as</span> integer <span class=hljs-keyword>as</span> text
number to integer to text
number.toInteger().toText()

number to Integer to <span class=hljs-built_in>String</span> to uppercase
number.toInteger().toString().toUpperCase()</code></pre><p>From this little exercise, I realized that I like 'to' better than 'as' because a common conversion phrase in English is 'convert from _ to _'. Also, it just felt more comfortable (and faster) writing only text, compared to writing text and a period and two parentheses.</p> <p>One downside to using the stand-alone 'to' may be for method chaining. The operator precedence is not immediately obvious in some cases. And, it's not immediately obvious to me which method I would have to update in order for the stand-alone 'to' syntax to work.</p> </div> <br><br><br> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cp\u003EThis should be a really short post. There&#39;s not many possible ways of casting data types, right? So, in no particular order:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Estr(42)\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E42.toString()\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E(String) 42\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E42 as string\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E(implicit) \u003Ccode\u003E42\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EWe probably can&#39;t do much better than these ideas above. But, we \u003Cem\u003Ecan\u003C\u002Fem\u003E think about which option is the most intuitive for new programmers, and which syntax would fit well with the rest of the language, and which syntax is open enough for many other conversion types (including custom classes)\u003C\u002Fp\u003E\n\u003Ch3 id=\"re-str42\"\u003ERe: \u003Ccode\u003Estr(42)\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003EThe String type is the most commonly used data type, so it would make sense to simplify its usage. The 3-letter lower-case abbreviation is memorable enough after a few uses. Even though Python has \u003Ccode\u003Estr()\u003C\u002Fcode\u003E as a built-in standard method, programmers can have the same syntax with overloaded constructors in their custom classes, i.e., \u003Ccode\u003EMyClass(...)\u003C\u002Fcode\u003E. Unfortunately, one way that the built-in syntax is different than the custom syntax is that the built-in syntaxes are all lower-case and the classes are all starting with upper-case. Also, is the &#39;str&#39; abbreviation better than just having a &#39;text&#39; data type instead of &#39;string&#39; data type?\u003C\u002Fp\u003E\n\u003Ch3 id=\"re-42tostring\"\u003ERe: \u003Ccode\u003E42.toString()\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003ELanguages using this syntax either can&#39;t use the same syntax to convert from built-in data types to custom data types (classes), OR they have the concept of extension methods, which I really like having. With this syntax, IDEs could easily have auto-complete and suggestion for all possible conversions by doing \u003Ccode\u003E.to&lt;ctrl+space&gt;\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch4 id=\"re-42str\"\u003ERe: \u003Ccode\u003E42.str\u003C\u002Fcode\u003E\u003C\u002Fh4\u003E\n\u003Cp\u003EThis is a degenerative form of \u003Ccode\u003E42.toString()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EI did consider a version of this syntax for a little bit, but when working on a few more examples later in this post, I figured this syntax wouldn&#39;t be as intuitive or obvious in some cases, for example: \u003Ccode\u003Eday.seconds\u003C\u002Fcode\u003E would be ambiguous. It could mean getting the seconds out of the day rather than converting the full day to seconds. We would want to reserve this syntax for easily getting properties of an object rather than converting.\u003C\u002Fp\u003E\n\u003Ch3 id=\"re-string-42\"\u003ERe: \u003Ccode\u003E(String) 42\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003EThis option creates a brand new syntax just for casting. Instead of choosing this less intuitive route, let&#39;s see if we can re-use existing syntax to handle this data type conversion requirement. (Answer: Yes, we can)\u003C\u002Fp\u003E\n\u003Ch3 id=\"re-42-as-string\"\u003ERe: \u003Ccode\u003E42 as string\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003EI kind of liked how this syntax read, including \u003Ccode\u003E42 to String\u003C\u002Fcode\u003E. But, since I just complained about creating a new syntax for casting in the previous section. I&#39;ll hold off on this one for now. \u003C\u002Fp\u003E\n\u003Ch3 id=\"re-implicit-42\"\u003ERe: (implicit) \u003Ccode\u003E42\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003EPersonally, I prefer explicit syntax in order to avoid simple mistakes.\u003C\u002Fp\u003E\n\u003Ch2 id=\"summary\"\u003ESummary\u003C\u002Fh2\u003E\n\u003Cp\u003ECurrently, my top two choices for data type casting is \u003Ccode\u003E.toString()\u003C\u002Fcode\u003E and the more &#39;English&#39; version of that \u003Ccode\u003Eto String\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003ENow, let&#39;s just list a few more examples to see these two syntax in action:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003Edays \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E seconds\ndays to seconds\ndays.toSeconds()\n\nhours \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E days\nhours to days\nhours.toDays()\n\nkm \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E m\nkm to m\nkm.toM()\n\nnumber \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E integer \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E text\nnumber to integer to text\nnumber.toInteger().toText()\n\nnumber to Integer to \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E to uppercase\nnumber.toInteger().toString().toUpperCase()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EFrom this little exercise, I realized that I like &#39;to&#39; better than &#39;as&#39; because a common conversion phrase in English is &#39;convert from _ to _&#39;. Also, it just felt more comfortable (and faster) writing only text, compared to writing text and a period and two parentheses.\u003C\u002Fp\u003E\n\u003Cp\u003EOne downside to using the stand-alone &#39;to&#39; may be for method chaining. The operator precedence is not immediately obvious in some cases. And, it&#39;s not immediately obvious to me which method I would have to update in order for the stand-alone &#39;to&#39; syntax to work.\u003C\u002Fp\u003E\n",title:"Data Type Conversion Syntax",file:"2020-03-01-data-type-conversion-syntax.md",date:"2020-03-01",slug:"2020-03-01-data-type-conversion-syntax"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.4edb8f75.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.4edb8f75.js")}document.head.appendChild(s)</script> <script async data-goatcounter=https://anonsage.goatcounter.com/count src=//gc.zgo.at/count.js></script> 